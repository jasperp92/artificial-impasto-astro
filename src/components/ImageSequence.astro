---
import type { ImageMetadata } from "astro";
import { Image } from "astro:assets";

interface Props {
  folder: string;
  mode?: "step" | "fade";
}

const { folder, mode = "step" } = Astro.props;

// Bilder sammeln
const allImages = import.meta.glob<{ default: ImageMetadata }>(
  "/src/assets/range/**/*.{png,jpg,jpeg,webp}",
);

const images = Object.keys(allImages)
  .filter((path) => path.includes(`/range/${folder}/`))
  .sort();
---

<div
  class="relative w-full max-h-[80vh] overflow-hidden"
  data-sequence
  data-mode={mode}
>
  <!-- Dummy-Image für Höhe/Layout -->
  <Image
    src={allImages[images[0]]()}
    alt="layout reference"
    class="w-full h-auto object-contain opacity-0 pointer-events-none"
    aria-hidden="true"
  />

  <!-- Alle Frames übereinandergelegt -->
  {
    images.map((path, index) => (
      <Image
        src={allImages[path]()}
        alt={`Frame ${index}`}
        class="absolute inset-0 w-full h-auto object-contain opacity-0"
        data-frame={index}
        loading="lazy"
      />
    ))
  }
</div>

<script>
  window.addEventListener("DOMContentLoaded", () => {
    const container = document.querySelector("[data-sequence]");
    if (!container) return;

    const mode = container.dataset.mode;
    const images = Array.from(container.querySelectorAll("[data-frame]"));
    const total = images.length;

    let hoverActive = false;

    function renderFrame(exactFrame) {
      if (mode === "fade") {
        const baseFrame = Math.floor(exactFrame);
        const fade = exactFrame - baseFrame;

        images.forEach((img, i) => {
          if (i === baseFrame) {
            img.style.opacity = "1"; // bleibt voll sichtbar
            img.style.zIndex = "1";
          } else if (i === baseFrame + 1) {
            img.style.opacity = String(fade); // blendet drüber
            img.style.zIndex = "2"; // liegt oben
          } else {
            img.style.opacity = "0";
            img.style.zIndex = "0";
          }
        });
      } else {
        const frame = Math.min(total - 1, Math.round(exactFrame));
        images.forEach((img, i) => {
          img.style.opacity = i === frame ? "1" : "0";
          img.style.zIndex = i === frame ? "1" : "0";
        });
      }
    }

    // Scroll control (nur wenn nicht gehovered)
function onScroll() {
  if (hoverActive) return;

  const rect = container.getBoundingClientRect();
  const windowHeight = window.innerHeight;
  const offset = 200; // Start erst nach 200px Sichtbarkeit

  // Sichtbarkeit mit Offset berechnen
  let progress =
    (windowHeight - rect.top - offset) / (windowHeight + rect.height - offset);

  // Auf 0–1 begrenzen
  progress = Math.min(Math.max(progress, 0), 1);

  const exactFrame = progress * (total - 1);
  renderFrame(exactFrame);
}

    // Hover control
    container.addEventListener("mouseenter", () => {
      hoverActive = true;
    });

    container.addEventListener("mouseleave", () => {
      hoverActive = false;
      onScroll(); // zurück zum Scroll-Frame
    });

    container.addEventListener("mousemove", (e) => {
      if (!hoverActive) return;
      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const progress = Math.min(Math.max(x / rect.width, 0), 1);
      const exactFrame = progress * (total - 1);
      renderFrame(exactFrame);
    });

    // init
    window.addEventListener("scroll", onScroll, { passive: true });
    onScroll();
  });
</script>
