---
import type { ImageMetadata } from "astro";
import { Image } from "astro:assets";

interface Props {
  folder: string;
  mode?: "step" | "fade"; // Bilddarstellung
  invert?: boolean;
  withSlider?: boolean; // Slider-Steuerung
  withScroll?: boolean; // Scroll-Steuerung
}

const {
  folder,
  mode = "step",
  invert = false,
  withSlider = false,
  withScroll = true,
} = Astro.props;

const allImages = import.meta.glob<{ default: ImageMetadata }>(
  "/src/assets/images/range/**/*.{png,jpg,jpeg,webp}",
);

const allLabels = import.meta.glob<{ default: Record<string, string> }>(
  "/src/assets/images/range/**/labels.json",
  { eager: true },
);

const labelsObj =
  allLabels[`/src/assets/images/range/${folder}/labels.json`]?.default ?? {};

const labelsJSON = JSON.stringify(labelsObj);

let images = Object.keys(allImages)
  .filter((path) => path.includes(`/range/${folder}/`))
  .sort();

if (invert) {
  images = images.reverse();
}
---

<div
  class="relative w-full max-h-[90vh] overflow-hidden"
  data-sequence
  data-mode={mode}
  data-scroll={withScroll ? "true" : "false"}
>
  <!-- Dummy-Image -->
  <Image
    src={allImages[images[0]]()}
    alt="layout reference"
    class="w-full h-auto max-h-[90vh] object-contain opacity-0 pointer-events-none"
    aria-hidden="true"
  />

  <!-- Alle Frames -->
  {
    images.map((path, index) => (
      <Image
        src={allImages[path]()}
        alt={`Frame ${index}`}
        class="absolute inset-0 w-full h-auto max-h-[90vh] object-contain opacity-0"
        data-frame={index}
        loading="eager"
        decoding="async"
      />
    ))
  }

  <!-- Label -->
  <div class="my-4 rounded text-sm text-center" data-label></div>

  {
    withSlider && (
      <div class="w-full">
        <input
          type="range"
          min="0"
          max={images.length - 1}
          step={mode === "fade" ? "0.01" : "1"}
          value="0"
          class="range-slider"
          data-slider
        />
      </div>
    )
  }

  <!-- Labels JSON -->
  <script type="application/json" data-labels set:html={labelsJSON} />
</div>

<script is:inline>
  window.addEventListener("DOMContentLoaded", () => {
    const containers = document.querySelectorAll("[data-sequence]");
    if (!containers.length) return;

    containers.forEach((container) => {
      const mode = container.dataset.mode;
      const withScroll = container.dataset.scroll === "true";

      const images = Array.from(container.querySelectorAll("[data-frame]"));
      const total = images.length;
      const slider = container.querySelector("[data-slider]");
      const labelEl = container.querySelector("[data-label]");

      let labels = {};
      const labelsNode = container.querySelector("[data-labels]");
      if (labelsNode?.textContent?.trim()) {
        try {
          labels = JSON.parse(labelsNode.textContent);
        } catch {}
      }

      let hoverActive = false;
      let sliderActive = false;

      function renderFrame(exactFrame) {
        const frame = Math.min(total - 1, Math.round(exactFrame));

        if (mode === "fade") {
          const baseFrame = Math.floor(exactFrame);
          const fade = exactFrame - baseFrame;

          images.forEach((img, i) => {
            if (i === baseFrame) {
              img.style.opacity = "1";
              img.style.zIndex = "1";
            } else if (i === baseFrame + 1) {
              img.style.opacity = String(fade);
              img.style.zIndex = "2";
            } else {
              img.style.opacity = "0";
              img.style.zIndex = "0";
            }
          });
        } else {
          images.forEach((img, i) => {
            if (i === frame) {
              img.style.opacity = "1";
              img.style.zIndex = "1";
            } else if (i === 0) {
              // ✅ Erstes Bild bleibt immer als Fallback sichtbar
              img.style.opacity = "1";
              img.style.zIndex = "0";
            } else {
              img.style.opacity = "0";
              img.style.zIndex = "0";
            }
          });
        }

        if (slider && !sliderActive) {
          slider.value = exactFrame;
        }

        if (labelEl) {
          labelEl.textContent = getLabelForFrame(frame, labels, total);
        }
      }

      function getLabelForFrame(frame, labels, total) {
        // Prüfen ob Range-Modus aktiv
        if (
          labels.rangeStart !== undefined &&
          labels.rangeEnd !== undefined &&
          labels.label
        ) {
          const value =
            labels.rangeStart +
            (frame / (total - 1)) * (labels.rangeEnd - labels.rangeStart);
          return `${labels.label}: ${value.toFixed(2)}`;
        }

        // Klassischer Modus (falls JSON wie vorher ist)
        if (labels[frame]) return labels[frame];
        for (const key in labels) {
          if (key.includes("-")) {
            const [start, end] = key.split("-").map(Number);
            if (frame >= start && frame <= end) {
              return labels[key];
            }
          }
        }

        return "";
      }

      function onScroll() {
        if (hoverActive || sliderActive) return;

        const rect = container.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        const startOffset = 300;
        const endOffset = 400;

        let progress =
          (windowHeight - rect.top - startOffset) /
          (windowHeight + rect.height - startOffset - endOffset);

        progress = Math.min(Math.max(progress, 0), 1);

        const exactFrame = progress * (total - 1);
        renderFrame(exactFrame);
      }

      // Hover nur wenn kein Slider
      if (!slider) {
        container.addEventListener("mouseenter", () => {
          hoverActive = true;
        });
        container.addEventListener("mouseleave", () => {
          hoverActive = false;
          if (withScroll) onScroll();
        });
        container.addEventListener("mousemove", (e) => {
          if (!hoverActive) return;
          const rect = container.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const progress = Math.min(Math.max(x / rect.width, 0), 1);
          const exactFrame = progress * (total - 1);
          renderFrame(exactFrame);
        });
      }

      // Slider
      if (slider) {
        slider.addEventListener("input", (e) => {
          sliderActive = true;
          const exactFrame = parseFloat(e.target.value);
          renderFrame(exactFrame);
        });
        slider.addEventListener("change", () => {
          sliderActive = false;
        });
      }

      // init
      renderFrame(0);
      if (withScroll) {
        window.addEventListener("scroll", onScroll, { passive: true });
        onScroll();
      }
    });
  });
</script>

<style is:global>
  .range-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 4px;
    background: var(--color-zinc-500);
    outline: none;
    margin-top: 1rem;
  }

  /* Thumb (Light Mode = schwarz) */
  .range-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #000;
    cursor: pointer;
  }
  .range-slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #000;
    cursor: pointer;
  }

  /* Dark Mode (weiß) */
  .dark input.range-slider::-webkit-slider-thumb {
    background: #fff !important;
  }
  .dark input.range-slider::-moz-range-thumb {
    background: #fff !important;
  }
</style>
